/* @file

    Build configuration script of RUCI.
    SPDX-License-Identifier: WTFPL

*/
use std::{env, fs};
use std::path::{MAIN_SEPARATOR, Path};
use regex::Regex;
use syn::{Expr, Item, Meta};
use string_builder::Builder;

/// Binding Vector:
/// Vec<File, Function, Method, Mapping>
fn generate_binding(path:&str) ->Vec<(String, String, String, String)> {
    let mut i = Vec::new();
    let paths = fs::read_dir(path).unwrap();
    let match_regex = Regex::new(
        r#"^ *(?<method>(GET|POST)) *, *(?<mapping>[a-zA-Z0-9\-.?,'/\\+&%$#_]+) *$"#
    ).unwrap();
    for path in paths {
        let path_name= path.unwrap().path();
        let rust_file = fs::read_to_string(&path_name).expect("Unable to read rust file");
        let ast = syn::parse_file(&rust_file).expect(&*rust_file);
        // Iterate file to find functions.
        for item in ast.items {
            match item {
                Item::Fn(item_fn) => {
                    // Good, found a function.
                    // Then find if it has #[doc] attribute.
                    for attr in item_fn.attrs {
                        if attr.path().is_ident("doc"){
                            let Meta::NameValue(attr_meta) = attr.meta else {panic!("No way!")};
                            let Expr::Lit(attr_lit) = attr_meta.value else {panic!("No way!")};
                            let syn::Lit::Str(attr_lit_str) = attr_lit.lit else {panic!("No way!")};
                            let content = attr_lit_str.value();
                            let match_result = match_regex.captures(&*content);
                            match match_result {
                                Some(captures) => {
                                    i.push((
                                        String::from(path_name.to_str().unwrap()),
                                        item_fn.sig.ident.to_string(),
                                        String::from(captures.name("method").unwrap().as_str()),
                                        String::from(captures.name("mapping").unwrap().as_str())
                                    ));
                                }
                                None => {}
                            }
                        }
                    }
                }
                _ => {}
            }
        }
    }
    i
}

fn main() {

    let file_name_format = format!(r#"(?<name>[^{}]+)\.rs$"#,MAIN_SEPARATOR);
    let file_name_regex = Regex::new(
        &*file_name_format
    ).unwrap();
    // Generate bindings
    let bindings = generate_binding("src/controller");
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("bindings.gen.rs");
    let mut builder = Builder::default();
    builder.append (
r#" // Generated by build script. DO NOT EDIT!
lazy_static! {
    static ref mapper:HashMap<&'static str, fn(cgi::Request)->Response> = {
        let mut map:HashMap<&'static str, fn(cgi::Request)->Response> = HashMap::new();
"#
    );
    for i in bindings {
        let file_name_capture = file_name_regex.captures(&*i.0).expect(&*i.0);
        builder.append (
            format! (
                "        map.insert(\"{}\",{}::{} as fn(cgi::Request)->Response);\n",
                i.3,
                file_name_capture.name("name").unwrap().as_str(),
                i.1
            )
        );
    }
    builder.append (
r#"
        map
    };
}"#);
     //        map.insert("/info",info::info as fn(cgi::Request)->Response);
    fs::write(
        &dest_path,
        builder.string().expect("Invalid mapping!")
    ).unwrap();

    // Rust toolchain bug
    if std::env::var("CARGO_CFG_TARGET_ENV").unwrap()=="musl" {
        println!("cargo::rustc-link-arg=-Wl,--dynamic-linker=/lib/ld-musl-{}.so.1",
                 std::env::var("CARGO_CFG_TARGET_ARCH").unwrap());
    }
}